import React, { useState, useEffect, useRef } from 'react';

const ImprovedStencilCreator = () => {
  const [image, setImage] = useState(null);
  const [mode, setMode] = useState('Edges');
  const [intensity, setIntensity] = useState(50);
  const [sharpness, setSharpness] = useState(50);
  const originalCanvasRef = useRef(null);
  const processedCanvasRef = useRef(null);

  useEffect(() => {
    if (image) {
      const img = new Image();
      img.onload = () => {
        drawOriginalImage(img);
        processImage(img);
      };
      img.src = URL.createObjectURL(image);
    }
  }, [image, mode, intensity, sharpness]);

  const drawOriginalImage = (img) => {
    const canvas = originalCanvasRef.current;
    const ctx = canvas.getContext('2d');
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
  };

  const processImage = (img) => {
    const canvas = processedCanvasRef.current;
    const ctx = canvas.getContext('2d');
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);

    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    let processedData;

    switch (mode) {
      case 'Edges':
        processedData = applyEdgeDetection(imageData);
        break;
      case 'Thin':
        processedData = applyThinning(imageData);
        break;
      case 'Threshold':
        processedData = applyThreshold(imageData);
        break;
      case 'Adaptive':
        processedData = applyAdaptiveThreshold(imageData);
        break;
      case 'Color':
        processedData = applyColorFilter(imageData);
        break;
      default:
        processedData = imageData;
    }

    ctx.putImageData(processedData, 0, 0);
  };

  const applyEdgeDetection = (imageData) => {
    const { width, height, data } = imageData;
    const output = new ImageData(width, height);
    const sobel = (x, y) => {
      const gx = 
        -data[((y-1)*width + x-1) * 4] + data[((y-1)*width + x+1) * 4] +
        -2 * data[(y*width + x-1) * 4] + 2 * data[(y*width + x+1) * 4] +
        -data[((y+1)*width + x-1) * 4] + data[((y+1)*width + x+1) * 4];
      const gy = 
        -data[((y-1)*width + x-1) * 4] - 2 * data[((y-1)*width + x) * 4] - data[((y-1)*width + x+1) * 4] +
        data[((y+1)*width + x-1) * 4] + 2 * data[((y+1)*width + x) * 4] + data[((y+1)*width + x+1) * 4];
      return Math.sqrt(gx*gx + gy*gy);
    };

    const factor = intensity / 50;
    const sharpFactor = sharpness / 50;

    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        const idx = (y * width + x) * 4;
        const edge = sobel(x, y) * factor;
        const sharpEdge = Math.min(255, edge * sharpFactor);
        output.data[idx] = output.data[idx + 1] = output.data[idx + 2] = sharpEdge;
        output.data[idx + 3] = 255;
      }
    }
    return output;
  };

  const applyThinning = (imageData) => {
    const { width, height, data } = imageData;
    const output = new ImageData(width, height);
    const threshold = 128 + (intensity - 50) * 2.55;
    const thinFactor = 1 + (sharpness - 50) / 25;

    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        const idx = (y * width + x) * 4;
        const avg = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
        const neighbors = [
          (data[((y-1)*width + x-1) * 4] + data[((y-1)*width + x-1) * 4 + 1] + data[((y-1)*width + x-1) * 4 + 2]) / 3,
          (data[((y-1)*width + x) * 4] + data[((y-1)*width + x) * 4 + 1] + data[((y-1)*width + x) * 4 + 2]) / 3,
          (data[((y-1)*width + x+1) * 4] + data[((y-1)*width + x+1) * 4 + 1] + data[((y-1)*width + x+1) * 4 + 2]) / 3,
          (data[(y*width + x-1) * 4] + data[(y*width + x-1) * 4 + 1] + data[(y*width + x-1) * 4 + 2]) / 3,
          (data[(y*width + x+1) * 4] + data[(y*width + x+1) * 4 + 1] + data[(y*width + x+1) * 4 + 2]) / 3,
          (data[((y+1)*width + x-1) * 4] + data[((y+1)*width + x-1) * 4 + 1] + data[((y+1)*width + x-1) * 4 + 2]) / 3,
          (data[((y+1)*width + x) * 4] + data[((y+1)*width + x) * 4 + 1] + data[((y+1)*width + x) * 4 + 2]) / 3,
          (data[((y+1)*width + x+1) * 4] + data[((y+1)*width + x+1) * 4 + 1] + data[((y+1)*width + x+1) * 4 + 2]) / 3,
        ];
        const darkNeighbors = neighbors.filter(n => n < threshold).length;
        const value = avg < threshold && darkNeighbors >= 2 * thinFactor ? 0 : 255;
        output.data[idx] = output.data[idx + 1] = output.data[idx + 2] = value;
        output.data[idx + 3] = 255;
      }
    }
    return output;
  };

  const applyThreshold = (imageData) => {
    const { data } = imageData;
    const output = new ImageData(new Uint8ClampedArray(data), imageData.width, imageData.height);
    const threshold = 128 + (intensity - 50) * 2.55;
    const contrastFactor = 1 + (sharpness - 50) / 50;

    for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      const contrastedAvg = 128 + (avg - 128) * contrastFactor;
      const value = contrastedAvg > threshold ? 255 : 0;
      output.data[i] = output.data[i + 1] = output.data[i + 2] = value;
    }
    return output;
  };

  const applyAdaptiveThreshold = (imageData) => {
    const { width, height, data } = imageData;
    const output = new ImageData(width, height);
    const blockSize = Math.max(3, Math.floor(width / 20));
    const adaptiveThreshold = 128 + (intensity - 50) * 2.55;
    const contrastFactor = 1 + (sharpness - 50) / 50;

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        let sum = 0, count = 0;
        for (let by = Math.max(0, y - blockSize); by < Math.min(height, y + blockSize); by++) {
          for (let bx = Math.max(0, x - blockSize); bx < Math.min(width, x + blockSize); bx++) {
            const bidx = (by * width + bx) * 4;
            sum += (data[bidx] + data[bidx + 1] + data[bidx + 2]) / 3;
            count++;
          }
        }
        const avg = sum / count;
        const pixelValue = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
        const contrastedValue = 128 + (pixelValue - 128) * contrastFactor;
        const value = contrastedValue > avg - adaptiveThreshold ? 255 : 0;
        output.data[idx] = output.data[idx + 1] = output.data[idx + 2] = value;
        output.data[idx + 3] = 255;
      }
    }
    return output;
  };

  const applyColorFilter = (imageData) => {
    const { data } = imageData;
    const output = new ImageData(new Uint8ClampedArray(data), imageData.width, imageData.height);
    const factor = intensity / 50;
    const contrastFactor = 1 + (sharpness - 50) / 50;

    for (let i = 0; i < data.length; i += 4) {
      for (let j = 0; j < 3; j++) {
        const contrastedValue = 128 + (data[i + j] - 128) * contrastFactor;
        output.data[i + j] = Math.min(255, Math.max(0, contrastedValue * factor));
      }
    }
    return output;
  };

  const handleFileUpload = (e) => {
    if (e.target.files && e.target.files[0]) {
      setImage(e.target.files[0]);
    }
  };

  const downloadStencil = () => {
    const canvas = processedCanvasRef.current;
    const link = document.createElement('a');
    link.download = 'improved_stencil.png';
    link.href = canvas.toDataURL();
    link.click();
  };

  return (
    <div className="flex flex-col items-center p-4 bg-gray-100 min-h-screen">
      <h1 className="text-2xl font-bold mb-4">Creador de Stencils Mejorado</h1>
      
      <div className="w-full max-w-4xl bg-white p-6 rounded-lg shadow-md">
        <input type="file" accept="image/*" onChange={handleFileUpload} className="mb-4" />

        {image && (
          <>
            <div className="flex flex-wrap justify-center gap-2 mb-4">
              {['Edges', 'Thin', 'Threshold', 'Adaptive', 'Color'].map((m) => (
                <button
                  key={m}
                  onClick={() => setMode(m)}
                  className={`px-4 py-2 rounded ${mode === m ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                >
                  {m}
                </button>
              ))}
            </div>

            <div className="mb-4">
              <input
                type="range"
                min="0"
                max="100"
                value={intensity}
                onChange={(e) => setIntensity(Number(e.target.value))}
                className="w-full"
              />
              <div className="flex justify-between">
                <span>Intensity</span>
                <span>{intensity}%</span>
              </div>
            </div>

            <div className="mb-4">
              <input
                type="range"
                min="0"
                max="100"
                value={sharpness}
                onChange={(e) => setSharpness(Number(e.target.value))}
                className="w-full"
              />
              <div className="flex justify-between">
                <span>Sharp</span>
                <span>Soft</span>
              </div>
            </div>

            <div className="flex flex-col md:flex-row">
              <div className="md:w-1/2 pr-2">
                <h2 className="text-xl font-semibold mb-2">Original</h2>
                <canvas ref={originalCanvasRef} className="w-full border" />
              </div>
              <div className="md:w-1/2 pl-2">
                <h2 className="text-xl font-semibold mb-2">Processed</h2>
                <canvas ref={processedCanvasRef} className="w-full border" />
              </div>
            </div>

            <button
              onClick={downloadStencil}
              className="w-full mt-4 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
            >
              Download Stencil
            </button>
          </>
        )}
      </div>
    </div>
  );
};

export default ImprovedStencilCreator;
