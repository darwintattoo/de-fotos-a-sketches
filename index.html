import React, { useState, useEffect, useRef } from 'react';

/**
 * SketchCreator Component
 * 
 * Este componente permite cargar una imagen y convertirla en un sketch
 * con varios parámetros ajustables para personalizar el resultado.
 */
const SketchCreator = () => {
  // Estados para la imagen y los parámetros de ajuste
  const [originalImage, setOriginalImage] = useState(null);
  const [edgeStrength, setEdgeStrength] = useState(50);
  const [edgeSensitivity, setEdgeSensitivity] = useState(20);
  const [fineDetail, setFineDetail] = useState(30);
  const [threshold, setThreshold] = useState(128);
  const [invert, setInvert] = useState(false);

  // Referencias a los elementos canvas
  const originalCanvasRef = useRef(null);
  const sketchCanvasRef = useRef(null);

  // Efecto para cargar y procesar la imagen cuando se selecciona
  useEffect(() => {
    if (originalImage) {
      const img = new Image();
      img.onload = () => {
        const resizedImage = resizeImage(img, 1000);
        const originalCanvas = originalCanvasRef.current;
        const sketchCanvas = sketchCanvasRef.current;
        originalCanvas.width = sketchCanvas.width = resizedImage.width;
        originalCanvas.height = sketchCanvas.height = resizedImage.height;
        
        const originalCtx = originalCanvas.getContext('2d');
        originalCtx.drawImage(resizedImage, 0, 0);
        
        updateEffect();
      };
      img.src = originalImage;
    }
  }, [originalImage]);

  // Efecto para actualizar el sketch cuando cambian los parámetros
  useEffect(() => {
    if (originalImage) {
      updateEffect();
    }
  }, [edgeStrength, edgeSensitivity, fineDetail, threshold, invert]);

  /**
   * Maneja la carga de una nueva imagen
   * @param {Event} e - Evento de cambio del input de archivo
   */
  const handleImageUpload = (e) => {
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = (event) => {
      setOriginalImage(event.target.result);
    };
    reader.readAsDataURL(file);
  };

  /**
   * Redimensiona una imagen manteniendo su proporción
   * @param {HTMLImageElement} img - Imagen a redimensionar
   * @param {number} maxDim - Dimensión máxima (ancho o alto)
   * @returns {HTMLCanvasElement} Canvas con la imagen redimensionada
   */
  const resizeImage = (img, maxDim) => {
    const canvas = document.createElement('canvas');
    let width = img.width;
    let height = img.height;

    if (width > height) {
      if (width > maxDim) {
        height *= maxDim / width;
        width = maxDim;
      }
    } else {
      if (height > maxDim) {
        width *= maxDim / height;
        height = maxDim;
      }
    }

    canvas.width = width;
    canvas.height = height;
    canvas.getContext('2d').drawImage(img, 0, 0, width, height);
    return canvas;
  };

  /**
   * Actualiza el efecto de sketch basado en los parámetros actuales
   */
  const updateEffect = () => {
    if (!originalCanvasRef.current || !sketchCanvasRef.current) return;

    const originalCtx = originalCanvasRef.current.getContext('2d');
    const sketchCtx = sketchCanvasRef.current.getContext('2d');
    const imageData = originalCtx.getImageData(0, 0, originalCanvasRef.current.width, originalCanvasRef.current.height);
    
    const sketchData = createDetailedSketchEffect(
      imageData, 
      edgeStrength / 100, 
      edgeSensitivity, 
      fineDetail / 100, 
      threshold, 
      invert
    );

    sketchCtx.putImageData(sketchData, 0, 0);
  };

  /**
   * Crea el efecto de sketch detallado
   * @param {ImageData} imageData - Datos de la imagen original
   * @param {number} edgeStrength - Fuerza de los bordes
   * @param {number} edgeSensitivity - Sensibilidad de detección de bordes
   * @param {number} fineDetail - Nivel de detalle fino
   * @param {number} threshold - Umbral para binarización
   * @param {boolean} invert - Si se debe invertir el resultado
   * @returns {ImageData} Datos de la imagen procesada
   */
  const createDetailedSketchEffect = (imageData, edgeStrength, edgeSensitivity, fineDetail, threshold, invert) => {
    const { width, height, data } = imageData;
    const result = new ImageData(new Uint8ClampedArray(data), width, height);
    const resultData = result.data;

    const grayScale = new Uint8ClampedArray(width * height);
    for (let i = 0; i < data.length; i += 4) {
      grayScale[i/4] = (data[i] * 0.3 + data[i+1] * 0.59 + data[i+2] * 0.11);
    }

    const edges = detectEdges(grayScale, width, height, edgeStrength, edgeSensitivity);
    applyFineDetail(edges, grayScale, width, height, fineDetail);

    for (let i = 0; i < edges.length; i++) {
      let value = edges[i] > threshold ? 0 : 255;
      if (invert) value = 255 - value;
      const idx = i * 4;
      resultData[idx] = resultData[idx + 1] = resultData[idx + 2] = value;
      resultData[idx + 3] = 255;
    }

    return result;
  };

  /**
   * Detecta los bordes en una imagen
   * @param {Uint8ClampedArray} data - Datos de la imagen en escala de grises
   * @param {number} width - Ancho de la imagen
   * @param {number} height - Alto de la imagen
   * @param {number} strength - Fuerza de los bordes
   * @param {number} sensitivity - Sensibilidad de detección
   * @returns {Uint8ClampedArray} Mapa de bordes detectados
   */
  const detectEdges = (data, width, height, strength, sensitivity) => {
    const result = new Uint8ClampedArray(data.length);
    const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
    const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];

    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        let gx = 0, gy = 0;
        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const idx = (y + ky) * width + (x + kx);
            gx += data[idx] * sobelX[(ky + 1) * 3 + (kx + 1)];
            gy += data[idx] * sobelY[(ky + 1) * 3 + (kx + 1)];
          }
        }
        const g = Math.sqrt(gx * gx + gy * gy) * strength;
        result[y * width + x] = g > sensitivity ? g : 0;
      }
    }
    return result;
  };

  /**
   * Aplica un efecto de detalle fino al mapa de bordes
   * @param {Uint8ClampedArray} edges - Mapa de bordes
   * @param {Uint8ClampedArray} original - Imagen original en escala de grises
   * @param {number} width - Ancho de la imagen
   * @param {number} height - Alto de la imagen
   * @param {number} amount - Cantidad de detalle fino a aplicar
   */
  const applyFineDetail = (edges, original, width, height, amount) => {
    for (let i = 0; i < edges.length; i++) {
      edges[i] = Math.max(edges[i], (255 - original[i]) * amount);
    }
  };

  return (
    <div className="p-4 bg-gray-800 min-h-screen text-white">
      <h1 className="text-3xl font-bold mb-6 text-center text-blue-300">Creador de Sketch Detallado</h1>
      
      <div className="max-w-4xl mx-auto bg-gray-700 p-6 rounded-lg shadow-xl">
        <input 
          type="file" 
          onChange={handleImageUpload} 
          accept="image/*" 
          className="mb-4 text-blue-300"
        />

        <div className="flex flex-wrap justify-center gap-4 mb-4">
          <canvas ref={originalCanvasRef} className="border border-blue-300"></canvas>
          <canvas ref={sketchCanvasRef} className="border border-blue-300"></canvas>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label className="block text-blue-300">Fuerza de Bordes: {edgeStrength}</label>
            <input 
              type="range" 
              min="0" 
              max="100" 
              value={edgeStrength} 
              onChange={(e) => setEdgeStrength(Number(e.target.value))} 
              className="w-full"
            />
          </div>
          <div>
            <label className="block text-blue-300">Sensibilidad de Bordes: {edgeSensitivity}</label>
            <input 
              type="range" 
              min="0" 
              max="100" 
              value={edgeSensitivity} 
              onChange={(e) => setEdgeSensitivity(Number(e.target.value))} 
              className="w-full"
            />
          </div>
          <div>
            <label className="block text-blue-300">Detalle Fino: {fineDetail}</label>
            <input 
              type="range" 
              min="0" 
              max="100" 
              value={fineDetail} 
              onChange={(e) => setFineDetail(Number(e.target.value))} 
              className="w-full"
            />
          </div>
          <div>
            <label className="block text-blue-300">Umbral: {threshold}</label>
            <input 
              type="range" 
              min="0" 
              max="255" 
              value={threshold} 
              onChange={(e) => setThreshold(Number(e.target.value))} 
              className="w-full"
            />
          </div>
          <div className="flex items-center">
            <input 
              type="checkbox" 
              checked={invert} 
              onChange={(e) => setInvert(e.target.checked)} 
              className="mr-2"
            />
            <label className="text-blue-300">Invertir Colores</label>
          </div>
        </div>
      </div>
    </div>
  );
};

export default SketchCreator;
